接下来我会给你安排任务，务必先了解我的需求：
  目前只完成了以下模块：认证、好友、好友请求、搜索；未完成的没有参考意义。
  参考我之前实现的 search 模块（符合最新架构要求）
四层架构：service(API交互) -> store(数据操作)->composable( 响应组件操作与需求)->ui(具体实现不用管)
📋 实现步骤（以 search 模块为例）

类型定义 (types/search.ts)
	定义搜索相关接口（搜索参数、结果类型、响应格式）
	注：转换函数放在 types 文件中

Service 层 (service/searchService.ts)
	实现核心 API 方法（searchUsers、searchGroups）
	自动携带 Authorization Bearer token
	处理 API 响应和错误（用 console 标记执行位置）
	注：不在此层添加 snackbar（因为不是直接由组件调用）

Store 层 (stores/searchStore.ts)
	定义状态（查询词、类型、结果列表、分页信息）
	实现 Actions（setUserSearchResults、appendUserSearchResults、clearResults 等）
	只负责数据存储和管理，**不直接调用 Service**
	数据更新方法供 Composable 调用
	不处理用户反馈（如 snackbar）

Composable 层 (composables/useSearch.ts)
	Composable 职责说明：
	1. 作为 store 的门面，提供统一接口
	2. 调用 Service 执行 API 请求
	3. 处理业务逻辑（防抖、错误处理、用户反馈）
	4. 组合多个 Store/Service（如果需要）
	5. 本地状态管理（与 Store 无关的组件级状态）
	6. 暴露 SearchType 枚举供模板使用

文档更新 (documents/API接入与Pinia封装.md)
	更新 search 模块各层职责说明

通用设计说明：
1、获取初始数据在store层面封装，在auth的login中进行；resetStore在logout中进行。
2、每部分的代码需要添加类似的注释：
/**
   * 创建群聊
   *
   * 执行流程：
   * 1. 调用 groupService 发送创建群聊请求
   * 2. 创建成功后，将新群聊添加到 groupStore
   * 3. 将当前用户（创建者）添加为群成员，角色设置为 OWNER
   * 4. 从 authStore 获取用户名，构建成员信息
   * 5. 记录操作日志并返回群聊对象
   *
   * 数据流：
   * - 输入：创建参数（群名、头像、简介）
   * - 输出：完整的群聊对象
   * - 副作用：更新 groupStore 中的 groups 和 members
   *
   * 使用场景：
   * - 用户创建新的群聊
   * - 群聊创建成功后的自动处理
   *
   * @param {CreateGroupParams} params - 创建群聊的参数
   * @returns {Promise<Group>} 创建成功的群聊对象
   */

3、API请求体必须要包含所有字段。对于前端为undefine的可选字段，请求体应该设置为null
4、Store 的 action 如果直接由组件调用，应该有 snackbar
如果 action 由 composable 调用，则 snackbar 在 composable 层
Service 层应该没有 snackbar（因为不是直接由组件调用）
snackbar和console可以同时使用。
5、数据流：composable->params->Service:API->response->composable:转换函数->标准数据格式->store

架构统一要求：
   - 所有 Service 调用必须移到 Composable 层
   - Service 层禁止导入和使用 snackbar
   - Store 层只管理数据，不调用 Service
   - Composable 作为唯一门面，暴露给组件
   - 确保错误处理在 Composable 层完成
   - 确保composable封装了用于login和logout的init（没有初始化拉取的不需要封装）和reset

你需要完成的任务：
    参考search模块实现的代码，封装一个localSearch模块，用来搜索前端缓存中的char、group和friend